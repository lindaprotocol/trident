{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Trident - TRON Java SDK","text":""},{"location":"#overview","title":"Overview","text":"<p>Trident is a lightweight Java SDK for interacting with the TRON blockchain. It provides a simple and efficient way to integrate TRON functionality into your Java applications.</p> <p>Trident includes three main modules:</p> Module Description trident-core Wrapping functions for easily interacting with TRON system and smart contracts trident-abi Datatypes and ABI encoders/decoders trident-utils Tools including encryption, conversion, etc."},{"location":"#features","title":"Features","text":"<ul> <li>Complete implementation of TRON's gRPC interfaces</li> <li>Smart contract deployment and interaction</li> <li>Wallet key management and address utilities</li> <li>Transaction building and signing</li> <li>TRC10/TRC20/TRC721 token support</li> </ul>"},{"location":"#install","title":"Install","text":"<p>Trident is compiled with Java 1.8.</p>"},{"location":"#version-092-and-later","title":"Version 0.9.2 and Later","text":""},{"location":"#gradle","title":"Gradle","text":"<pre><code>implementation(\"io.github.tronprotocol:trident:0.9.2\")  // Check Maven Central for newer versions\n</code></pre>"},{"location":"#maven","title":"Maven","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.tronprotocol&lt;/groupId&gt;\n    &lt;artifactId&gt;trident&lt;/artifactId&gt;\n    &lt;version&gt;0.9.2&lt;/version&gt;  &lt;!-- Check Maven Central for newer versions --&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"#previous-versions-092","title":"Previous Versions (&lt; 0.9.2)","text":"<p>For versions before 0.9.2, you'll need to build from source:</p> <ol> <li>Clone the repository from GitHub</li> <li>Build the project with required versions:<ul> <li>Java: 1.8.0_231</li> <li>Gradle: 5.6.4</li> </ul> </li> <li>Configure your project dependencies:</li> </ol> <pre><code>dependencies {\n    // protobuf &amp; grpc\n    implementation 'com.google.protobuf:protobuf-java:3.11.0'\n\n    implementation 'io.grpc:grpc-netty-shaded:1.31.0'\n    implementation 'io.grpc:grpc-netty:1.31.0'\n    implementation 'io.grpc:grpc-protobuf:1.31.0'\n    implementation 'io.grpc:grpc-stub:1.31.0'\n\n    implementation \"org.bouncycastle:bcprov-jdk15on:1.68\"\n\n    implementation fileTree(dir:'../core')\n    implementation fileTree(dir:'../utils')\n    implementation fileTree(dir:'../abi')\n    //if you are using the *.jar files, ues the following line\n    implementation fileTree(dir:'your path', include: '*.jar')\n\n    implementation 'com.google.guava:guava:28.0-jre'\n}\n</code></pre> <p>Version Notice</p> <p>We strongly recommend using version 0.9.2 or later, as newer versions are more stable and feature-rich, with all modules combined into a single package.</p>"},{"location":"#integrity-check","title":"Integrity Check","text":"<p>Starting from version 0.9.2, releases are published to Maven repository and signed with the GPG key:</p> <pre><code>pub: 3149 FCA5 6377 2D11 2624 9C36 CC3F 8CEA 7B0C 74D6\nuid: buildtrident@tron.network\n</code></pre> <p>Tip</p> <p>For security verification of the package, please refer to our Security Guide.</p>"},{"location":"#start-building-with-trident","title":"\ud83d\ude80 Start Building with Trident","text":"<p>Ready to explore Trident? Check out our Quick Start Guide to begin building on TRON blockchain!</p>"},{"location":"guides/keypair/key-management/","title":"KeyPair Management","text":"<p>TRON's signature algorithm is ECDSA, and the selected curve is SECP256K1.</p> <p>From version 0.1.3, trident-java has implemented a wrapper class for SECP256K1.KeyPair in Core to facilitate the generation of private keys and the conversion of private keys to addresses. This classpath is: <code>org.tron.trident.core.key.KeyPair</code></p>"},{"location":"guides/keypair/key-management/#generate-keypair","title":"Generate KeyPair","text":"<pre><code>KeyPair keyPair = KeyPair.generate();\n</code></pre>"},{"location":"guides/keypair/key-management/#import-keypair-with-private-key","title":"Import KeyPair with Private Key","text":"<pre><code>KeyPair keyPair = new KeyPair(\"your private key\");\n</code></pre>"},{"location":"guides/keypair/key-management/#get-private-public-key","title":"Get Private &amp; Public Key","text":"<pre><code>keyPair.toPrivateKey(); // String private key\nkeyPair.toPublicKey();  // String public key\n</code></pre> <p>Note</p> <p>The public key does not equal to address.</p>"},{"location":"guides/keypair/key-management/#get-address","title":"Get Address","text":"<pre><code>keyPair.toBase58CheckAddress(); // Get Base58Check address\nkeyPair.toHexAddress();        // Get Hex address\n</code></pre>"},{"location":"guides/keypair/key-management/#public-key-to-address","title":"Public Key to Address","text":"<p>Use a specific public key to convert to byte[], Base58Check or Hex address:</p> <pre><code>// The parent function, returns byte[]\nKeyPair.publicKeyToAddress(SECP256K1.PublicKey pubKey); \n\nKeyPair.publicKeyToBase58CheckAddress(SECP256K1.PublicKey pubKey);\n\nKeyPair.publicKeyToHexAddress(SECP256K1.PublicKey pubKey);\n</code></pre>"},{"location":"guides/keypair/key-management/#sign-transaction","title":"Sign Transaction","text":"<pre><code>// This function returns the signature message in byte[]\nKeyPair.signTransaction(byte[] txid, KeyPair keyPair);\n</code></pre> <p>Private Key Security</p> <p>Private key is the only credential to access and control your assets. Never share it with others and always keep a secure backup.</p>"},{"location":"guides/smart-contracts/abi/","title":"Application Binary Interface","text":"<p>The Application Binary Interface (ABI) is a data encoding scheme for working with smart contracts. The types defined in the ABI are the same as those you encounter when writing smart contracts with Solidity.</p>"},{"location":"guides/smart-contracts/abi/#using-abi-in-trident","title":"Using ABI in Trident","text":"<p>The <code>abi</code> package in Trident includes libraries to encode/decode ABIs. Take calling <code>function totalSupply() public view returns (uint256)</code> function as an example to illustrate how to interact with a contract using ABI</p> <pre><code>// 1. Define function parameters (empty for totalSupply)\nList&lt;Type&gt; inputParameters = Collections.emptyList();\n\n// 2. Create function and encode\nFunction function = new Function(\n    \"totalSupply\",     // Function name\n    inputParameters,   // Function input parameters\n    Arrays.asList(new TypeReference&lt;Uint256&gt;() {})  // Function output parameters\n);\nString encodedHex = FunctionEncoder.encode(function);\n\n// 3. Call the contract\nTransactionExtention txnExt = client.triggerConstantContract(\n    ownerAddress,      // Caller address\n    contractAddress,   // Contract address\n    encodedHex        // Encoded function call\n);\n\n// 4. Decode the result\nString result = Numeric.toHexString(txnExt.getConstantResult(0).toByteArray());\nBigInteger totalSupply = (BigInteger) FunctionReturnDecoder.decode(\n    result, \n    function.getOutputParameters()\n).get(0).getValue();\n\n// For tokens with 18 decimals (like JST), the result might be:\n// 9900000000000000000000000000\n</code></pre>"},{"location":"guides/smart-contracts/abi/#type-matching","title":"Type Matching","text":"<p>The parameter types in your code must exactly match the function definition in the smart contract. For example:</p> <pre><code>// In smart contract\nfunction transfer(address _to, uint _value) public returns (bool)  // uint is alias for uint256\n</code></pre> <pre><code>// In Java code - Correct \u2713\nList&lt;Type&gt; params = Arrays.asList(\n    new Address(\"TRxxxxxxxxxxxxxxxxxxxxxxxxxxx\"),  // address type\n    new Uint256(1000000)                         // uint256 type\n);\n\n// In Java code - Wrong \u2717\nList&lt;Type&gt; params = Arrays.asList(\n    new Utf8String(\"TRxxxxxxxxxxxxxxxxxxxxxxxxxxx\"),  // wrong type for address\n    new Int256(1000000)                             // wrong type for uint\n);\n</code></pre> <p>For TRC10 token, use <code>Uint256</code> even if the contract parameter is defined as <code>trcToken</code>:</p> <pre><code>// In smart contract\nfunction transferToken(address _to, trcToken _id, uint256 _amount) external;\n</code></pre> <pre><code>// In Java code\nList&lt;Type&gt; params = Arrays.asList(\n    new Address(\"TRxxxxxxxxxxxxxxxxxxxxxxxxxxx\"),  // address _to\n    new Uint256(1000016),                        // trcToken _id\n    new Uint256(1000000)                         // uint256 _amount\n);\n</code></pre> <p>Using incorrect types will result in transaction failure or unexpected behavior.</p>"},{"location":"guides/smart-contracts/deployment/","title":"Deploying Smart Contracts","text":"<p>Trident allows you to deploy smart contracts using ABI and bytecode. The deployment process consists of two steps:</p>"},{"location":"guides/smart-contracts/deployment/#1-compile-smart-contract","title":"1. Compile Smart Contract","text":"<p>First, compile your Solidity contract to get the bytecode and ABI. You can use:</p>"},{"location":"guides/smart-contracts/deployment/#solidity-compiler","title":"Solidity Compiler","text":"<pre><code>$ solc &lt;contract&gt;.sol --bin --abi --optimize -o &lt;output-dir&gt;/\n</code></pre> <p>This generates two files: - <code>&lt;contract&gt;.bin</code>: Contains the bytecode - <code>&lt;contract&gt;.abi</code>: Contains the ABI definition</p>"},{"location":"guides/smart-contracts/deployment/#online-tools","title":"Online Tools","text":"<p>You can also use online tools on TRON IDE</p>"},{"location":"guides/smart-contracts/deployment/#2-deploy-contract","title":"2. Deploy Contract","text":"<p>Once you have the bytecode and ABI, deploy the contract using Trident:</p> <pre><code>// Deploy contract\nTransactionExtention txn = client.deployContract(\n        \"MyContract\",                // Contract name\n        abiStr,                      // Contract ABI string\n        bytecode,                    // Contract bytecode\n        null,                        // Constructor parameters (if any)\n        100_000_000L,               // Fee limit (100 TRX)\n        100L,                        // Consume user resource percent (0-100)\n        10_000_000L,                // Origin energy limit\n        0L,                         // Call value (amount of TRX to send)\n        \"\",                         // Token ID (for TRC10 token, empty if not used)\n        0L                          // Token value (for TRC10 token)\n);\n\n// Sign and broadcast\nTransaction signedTxn = client.signTransaction(txn);\nString txid = client.broadcastTransaction(signedTxn);\n</code></pre>"},{"location":"guides/smart-contracts/deployment/#3-deploy-with-constructor-parameters","title":"3. Deploy with Constructor Parameters","text":"<p>If your contract has a constructor with parameters:</p> <pre><code>// Sample contract\ncontract Test {\n    uint256 public param;\n\n    constructor(uint256 p) {\n        param = p;\n    }\n}\n</code></pre> <p>You need to provide the constructor parameters:</p> <pre><code>// Prepare constructor parameters\nList&lt;Type&lt;?&gt;&gt; params = Arrays.asList(new Uint256(15));  // Initial value for param\n\n// Deploy with parameters\nTransactionExtention txn = client.deployContract(\n    \"MyContract\",                // Contract name\n    abiStr,                     // Contract ABI string\n    bytecode,                   // Contract bytecode\n    params,                     // Constructor parameters\n    100_000_000L,              // Fee limit (100 TRX)\n    100L,                       // Consume user resource percent (0-100)\n    10_000_000L,               // Origin energy limit\n    0L,                        // Call value (amount of TRX to send)\n    \"\",                        // Token ID (for TRC10 token)\n    0L                         // Token value (for TRC10 token)\n);\n</code></pre> <p>Note</p> <ul> <li>Make sure not to send TRX (call value) to a non-payable constructor</li> <li>For TRC10 token operations, provide the token ID and value</li> </ul>"},{"location":"guides/smart-contracts/interaction/","title":"Contract Interaction","text":"<p>Trident provides methods to interact with deployed smart contracts. There are two types of contract interactions:</p>"},{"location":"guides/smart-contracts/interaction/#view-functions-constant-call","title":"View Functions (Constant Call)","text":"<p>View functions read data from the blockchain without modifying state. These calls are free and don't require transaction signing:</p> <pre><code>// Call view function (e.g., balanceOf)\nFunction balanceOfFunction = new Function(\n        \"balanceOf\",\n        Collections.singletonList(new Address(accountAddr)),\n        Collections.singletonList(new TypeReference&lt;Uint256&gt;() {})\n);\n\nString encodedHex = FunctionEncoder.encode(balanceOfFunction);\n\nTransactionExtention txn = client.triggerConstantContract(\n        ownerAddress,    // Caller address\n        contractAddress, // Contract address\n        encodedHex      // Encoded function call\n);\n\n// Decode the result\nString result = Numeric.toHexString(txnExt.getConstantResult(0).toByteArray());\nBigInteger balance = (BigInteger) FunctionReturnDecoder.decode(\n        result, \n        balanceOfFunction.getOutputParameters()\n).get(0).getValue();\n</code></pre>"},{"location":"guides/smart-contracts/interaction/#state-modifying-functions","title":"State-Modifying Functions","text":"<p>Functions that modify contract state require a transaction and consume resources:</p> <pre><code>// Transfer tokens\nFunction trc20Transfer = new Function(\n        \"transfer\",\n        Arrays.asList(\n                new Address(toAddress),\n                new Uint256(BigInteger.valueOf(10).multiply(BigInteger.valueOf(10).pow(6))) //decimals\n        ),\n        Collections.singletonList(new TypeReference&lt;Bool&gt;() {})\n);\nString encodedHex = FunctionEncoder.encode(trc20Transfer);\n\nTransactionExtention transactionExtention = client.triggerContract(\n        fromAddr,        // Sender Address\n        contractAddress, // Contract Address\n        encodedHex,      // Encoded function call\n        0,              // call value\n        0,              // token value\n        null,           // token id\n        150_000_000L    // fee Limit\n);\n\n// Sign and broadcast\nTransaction signedTxn = client.signTransaction(transactionExtention);\nString txid = client.broadcastTransaction(signedTxn);\n</code></pre>"},{"location":"guides/smart-contracts/interaction/#error-handling","title":"Error Handling","text":"<p>Check the transaction status after execution:</p> <pre><code>// Check if the constant call was successful\nif (!txn.getResult().getResult()) {\n    String message = txn.getResult().getMessage().toStringUtf8();\n    throw new RuntimeException(\"Contract call failed: \" + message);\n}\n\n// For state-modifying functions, you can get the transaction receipt\nTransactionInfo info = client.getTransactionInfoById(txid);\nif (info.getResult() != SUCCESS) {\n    throw new RuntimeException(\"Transaction failed: \" + info.getResMessage().toStringUtf8());\n}\n</code></pre>"},{"location":"guides/smart-contracts/overview/","title":"Smart Contracts Overview","text":""},{"location":"guides/smart-contracts/overview/#introduction","title":"Introduction","text":"<p>TRON smart contracts are programs that run on the TRON Virtual Machine (TVM). The TVM is compatible with the Ethereum Virtual Machine (EVM), allowing developers to deploy and execute Solidity smart contracts.</p>"},{"location":"guides/smart-contracts/overview/#best-practices","title":"Best Practices","text":""},{"location":"guides/smart-contracts/overview/#resource-management","title":"Resource Management","text":"<ul> <li>Calculate required energy before deployment</li> <li>Set appropriate fee limits for transactions</li> <li>Monitor resource consumption</li> </ul>"},{"location":"guides/smart-contracts/overview/#security-considerations","title":"Security Considerations","text":"<ul> <li>Test contracts thoroughly before deployment</li> <li>Use verified contract patterns</li> <li>Consider having contracts audited</li> </ul>"},{"location":"guides/smart-contracts/overview/#performance-tips","title":"Performance Tips","text":"<ul> <li>Optimize contract code for lower energy costs</li> <li>Cache frequently accessed data</li> <li>Use batch operations when possible</li> </ul> <p>Note</p> <p>Smart contracts are immutable once deployed. Make sure to thoroughly test your contract before deployment.</p>"},{"location":"guides/transactions/signing/","title":"Transaction Signing","text":"<p>Transaction signing is a crucial security step that proves you have the authority to spend from an address. Trident provides multiple ways to sign transactions.</p>"},{"location":"guides/transactions/signing/#signing-methods","title":"Signing Methods","text":""},{"location":"guides/transactions/signing/#1-sign-with-apiwrapper-instance","title":"1. Sign with ApiWrapper Instance","text":"<p>The simplest way is to use the private key bound to your ApiWrapper instance:</p> <pre><code>// The private key is already bound when creating the client\nApiWrapper client = ApiWrapper.ofNile(\"your_private_key\");\n\n// Sign directly with bound private key\nTransaction signedTxn = client.signTransaction(transaction);\n</code></pre>"},{"location":"guides/transactions/signing/#2-sign-with-specific-keypair","title":"2. Sign with Specific KeyPair","text":"<p>You can also sign with any KeyPair:</p> <pre><code>// Create or import a KeyPair\nKeyPair keyPair = new KeyPair(\"private_key\");\n\n// Sign with specific KeyPair\nTransaction signedTxn = client.signTransaction(transaction, keyPair);\n</code></pre>"},{"location":"guides/transactions/signing/#signature-validation","title":"Signature Validation","text":"<p>Trident provides methods to validate signature correctness using transaction ID and signature message. The validation works by:</p> <ol> <li>Recovering the public key from the signed message</li> <li>Converting the public key to an address</li> <li>Comparing with the initiator's address</li> </ol>"},{"location":"guides/transactions/signing/#verify-methods","title":"Verify Methods","text":"<pre><code>// Verify using raw data\nboolean isValid = SignatureValidator.verify(byte[] txid, byte[] signature, byte[] ownerAddress);\n\n// Verify using String format\nboolean isValid = SignatureValidator.verify(String txid, String signature, String ownerAddress);\n</code></pre> <p>Note</p> <p>The transaction ID (txid) is obtained by calculating SHA256 of <code>Transaction.rawData</code></p> <p>Security Notice</p> <ul> <li>Never share or expose your private keys</li> <li>Always verify the transaction details before signing</li> <li>Keep your signing environment secure and isolated</li> </ul>"},{"location":"guides/transactions/transaction-guide/","title":"Transaction Guide","text":"<p>A transaction is an operation that needs to be recorded on the TRON blockchain. These on-chain operations (like TRX transfer, stake &amp; unstake, Trigger Smart Contract, etc.) require bandwidth and energy consumption.</p> <p>For security considerations, Trident builds all transactions locally and returns a <code>TransactionExtention</code> structure for signing and broadcasting, rather than relying on remote transaction construction.</p>"},{"location":"guides/transactions/transaction-guide/#transaction-lifecycle","title":"Transaction Lifecycle","text":"<p>A normal routine for sending a transaction is:</p> <pre><code>Create -&gt; Sign -&gt; Broadcast -&gt; (wait) -&gt; Lookup and get receipt\n</code></pre>"},{"location":"guides/transactions/transaction-guide/#1-create-transaction","title":"1. Create Transaction","text":"<p>Creating a transaction locally, for example:</p> <pre><code>// Transfer TRX\nTransactionExtention transactionExtention = client.transfer(\"from_address\", \"to_address\", amount);\n</code></pre>"},{"location":"guides/transactions/transaction-guide/#2-add-extra-parameters-optional","title":"2. Add Extra Parameters (Optional)","text":"<p><code>TransactionBuilder</code> allows you to add or modify parameters before signing:</p> <pre><code>TransactionBuilder builder = new TransactionBuilder(transaction); //transaction is transactionExtention.getTransaction();\nbuilder.setFeeLimit(100000000L);  // Only required for smart contract transactions, can also be set in triggerContract()\nbuilder.setMemo(\"memo\");\nTransaction transaction = builder.build();\n</code></pre>"},{"location":"guides/transactions/transaction-guide/#3-sign-transaction","title":"3. Sign Transaction","text":"<p>There are two ways to sign a transaction:</p>"},{"location":"guides/transactions/transaction-guide/#sign-with-the-binding-private-key","title":"Sign with the binding private key","text":"<pre><code>// Using the private key bound to ApiWrapper instance\nTransaction signedTxn = client.signTransaction(transaction);\n</code></pre>"},{"location":"guides/transactions/transaction-guide/#sign-with-a-specific-private-key","title":"Sign with a specific private key","text":"<pre><code>// Using any private key\nTransaction signedTxn = client.signTransaction(transaction, SECP256K1.KeyPair);\n</code></pre>"},{"location":"guides/transactions/transaction-guide/#4-broadcast-transaction","title":"4. Broadcast Transaction","text":"<pre><code>String txid = client.broadcastTransaction(signedTxn);\nSystem.out.println(\"Transaction sent: \" + txid);\n</code></pre> <p>Note</p> <p>Transaction hash may change due to any modification to the original transaction (except the signature). The hash is re-calculated before broadcasting.</p>"},{"location":"guides/transactions/transaction-guide/#5-verify-transaction","title":"5. Verify Transaction","text":"<pre><code>import org.tron.trident.proto.Response.TransactionInfo;\n\n// Get transaction info by ID\nTransactionInfo txInfo = client.getTransactionInfoById(txid);\nSystem.out.println(\"Transaction status: \" + (txInfo.getResult() == SUCCESS));\n</code></pre>"},{"location":"guides/transactions/transaction-guide/#advanced-transaction-creation","title":"Advanced Transaction Creation","text":"<p>By default, Trident builds transactions locally but needs to query the fullnode for block information:</p> <ol> <li>Gets latest BlockID info via <code>getBlock</code> API</li> <li>Sets reference block and expiration time</li> </ol> <p>For advanced users who are familiar with java-tron's internal mechanisms, Trident provides a way to optimize performance by manually specifying block information:</p> <pre><code>// Initialize client\nApiWrapper client = ApiWrapper.ofNile(\"your_private_key\");\n\n// Enable local creation with specified block info\nclient.enableLocalCreate(\n    blockId,       // Block ID from a recent block\n    expireTime     // Transaction expiration time (current timestamp + N hours)\n);\n\n// Create transaction (no block query needed)\nTransactionExtention txn = client.transfer(from, to, amount);\n\n// Remember to disable local creation when done\nclient.disableLocalCreate();\n</code></pre> <p>Advanced Usage</p> <ul> <li>This is an advanced feature that requires deep understanding of java-tron</li> <li>Incorrect block reference or expiration time may cause transaction failures</li> <li>Block ID must be from a recent block within the node's solid block range</li> <li>Always call <code>disableLocalCreate()</code> after you're done to release resources</li> <li>For most users, the default transaction creation method is recommended</li> </ul>"},{"location":"guides/transactions/transaction-guide/#transaction-types","title":"Transaction Types","text":"<p>Trident supports most types of transactions on TRON network. For details about transaction types, please refer to:</p> <ul> <li>Full Node API Overview</li> <li>Trident API Reference</li> </ul> <p>The transaction types include:</p> <ul> <li>Basic Transactions (TRX transfer, TRC10 token transfer)</li> <li>Account Operations (create, update, permissions)</li> <li>Smart Contract Operations (deploy, trigger, update)</li> <li>Resource Management (freeze, unfreeze, delegate)</li> <li>Network Governance (vote, proposal)</li> <li>And more...</li> </ul>"},{"location":"quickstart/getting-started/","title":"\ud83d\ude80 Getting Started with Trident","text":"<p>This guide will walk you through the basic operations using the Trident SDK.</p>"},{"location":"quickstart/getting-started/#initialize-client","title":"Initialize Client","text":"<p>The <code>ApiWrapper</code> in package client is the entrance of the wrapped APIs and smart contract functions. Before using functions in ApiWrapper, you should bind your private key to an ApiWrapper instance:</p> <pre><code>import org.tron.trident.core.ApiWrapper;\n\npublic class QuickStart {\n    public static void main(String[] args) {\n        // Connect to Nile testnet with tronGrid endpoint\n        ApiWrapper client = ApiWrapper.ofNile(\"your_private_key\");\n\n        // Or connect to Shasta testnet with tronGrid endpoint\n        // ApiWrapper client = ApiWrapper.ofShasta(\"your_private_key\");\n\n        // Or connect to mainnet with tronGrid endpoint (requires TronGrid API key)\n        // ApiWrapper client = ApiWrapper.ofMainnet(\"your_private_key\", \"your_api_key\");\n\n        // Initialize with custom RPC endpoints\n        // ApiWrapper client = new ApiWrapper(\n        //     \"grpc.example.com:50051\",     // Full node gRPC endpoint\n        //     \"grpc.example.com:50052\",     // Solidity node gRPC endpoint\n        //     \"your_private_key\"\n        // );\n    }\n}\n</code></pre> <p>Note</p> <p>For testing purposes, we recommend using the Nile testnet. You can get test tokens from the Nile Faucet.</p>"},{"location":"quickstart/getting-started/#basic-operations","title":"Basic Operations","text":""},{"location":"quickstart/getting-started/#get-account-balance","title":"Get Account Balance","text":"<pre><code>long balance = client.getAccountBalance(\"your_address\"); // balance in SUN (1 TRX = 1,000,000 SUN)\nSystem.out.println(\"Balance: \" + balance / 1_000_000.0 + \" TRX\");\n</code></pre>"},{"location":"quickstart/getting-started/#send-trx","title":"Send TRX","text":"<pre><code>import org.tron.trident.proto.Response.TransactionExtention;\nimport org.tron.trident.proto.Chain.Transaction;\n\n// Transfer 100 TRX\nlong amount = 100_000_000L; // Amount in SUN\nTransactionExtention txn = client.transfer(\"from_address\", \"to_address\", amount);\n\n// Sign and broadcast\nTransaction signedTxn = client.signTransaction(txn);\nString txid = client.broadcastTransaction(signedTxn);\nSystem.out.println(\"Transaction sent: \" + txid);\n</code></pre>"},{"location":"quickstart/getting-started/#transfer-trc20-token","title":"Transfer TRC20 Token","text":"<pre><code>import org.tron.trident.abi.FunctionEncoder;\nimport org.tron.trident.abi.TypeReference;\nimport org.tron.trident.abi.datatypes.Function;\nimport org.tron.trident.abi.datatypes.generated.Uint256;\nimport java.math.BigInteger;\n\n// Contract address of the TRC20 token\nString contractAddress = \"TXYZopYRdj2D9XRtbG411XZZ3kM5VkAeBf\"; // USDT contract on Nile testnet\n\n// Create transfer function\nFunction transfer = new Function(\n    \"transfer\",\n    Arrays.asList(\n        new Address(\"recipient_address\"),\n        new Uint256(BigInteger.valueOf(100_000_000L)) // Amount with decimals (e.g., 100 USDT)\n    ),\n    Arrays.asList(new TypeReference&lt;Bool&gt;() {})\n);\n\n// Encode function call\nString encodedHex = FunctionEncoder.encode(transfer);\n\n// Trigger contract\nTransactionExtention transactionExtention = client.triggerContract(\n        fromAddr,        // Sender Address\n        contractAddress, // Contract Address\n        encodedHex,      // Encoded function call\n        0,              // call value\n        0,              // token value\n        null,           // token id\n        150_000_000L    // fee Limit\n);\n\n// Sign and broadcast\nTransaction signedTxn = client.signTransaction(transactionExtention);\nString txid = client.broadcastTransaction(signedTxn);\nSystem.out.println(\"Token transfer sent: \" + txid);\n</code></pre> <p>Important Considerations</p> <p>When working with TRC20 tokens:</p> <ol> <li> <p>Token Decimals</p> <ul> <li>Check the token's decimal places (e.g., USDT uses 6 decimals)</li> <li>Adjust the amount accordingly (e.g., 1 USDT = 1_000_000)</li> </ul> </li> <li> <p>Transaction Settings</p> <ul> <li>Set an appropriate fee limit for contract calls</li> <li>Handle contract revert errors in production code</li> </ul> </li> </ol>"},{"location":"quickstart/getting-started/#query-transaction","title":"Query Transaction","text":"<pre><code>import org.tron.trident.proto.Response.TransactionInfo;\n\n// Get transaction info by ID\nTransactionInfo txInfo = client.getTransactionInfoById(txid);\nSystem.out.println(\"Transaction status: \" + txInfo.getResult());\n</code></pre>"},{"location":"quickstart/getting-started/#learn-more","title":"Learn More","text":"<ul> <li>Learn more about Key Management</li> <li>Explore Transaction Guide</li> <li>Check out Smart Contract Integration</li> <li>View the complete API Reference</li> </ul>"},{"location":"security/gpg-verification/","title":"GPG Verification Guide","text":"<p>Prerequisites</p> <p>You need to have GPG (GNU Privacy Guard) installed on your system:</p> <ul> <li>Windows: Gpg4win</li> <li>macOS: <code>brew install gpg</code></li> <li>Linux: <code>sudo apt-get install gnupg</code> or <code>sudo yum install gnupg</code></li> </ul>"},{"location":"security/gpg-verification/#overview","title":"Overview","text":"<p>Starting from version 0.9.2, releases are published to Maven repository and signed with the GPG key:</p> <pre><code>pub: 3149 FCA5 6377 2D11 2624 9C36 CC3F 8CEA 7B0C 74D6\nuid: buildtrident@tron.network\n</code></pre>"},{"location":"security/gpg-verification/#verification-steps","title":"Verification Steps","text":"<ol> <li> <p>Import the Trident public key:     <pre><code>gpg --keyserver hkp://keys.openpgp.org --recv-keys 3149FCA563772D1126249C36CC3F8CEA7B0C74D6\n</code></pre></p> </li> <li> <p>Download package files:     <pre><code>wget https://repo1.maven.org/maven2/io/github/tronprotocol/trident/0.9.2/trident-0.9.2.jar\nwget https://repo1.maven.org/maven2/io/github/tronprotocol/trident/0.9.2/trident-0.9.2.jar.asc\n</code></pre></p> </li> <li> <p>Verify the signature:     <pre><code>gpg --verify trident-0.9.2.jar.asc trident-0.9.2.jar\n</code></pre></p> <p>A successful verification will show: <pre><code>gpg: Signature made Mon Mar  3 18:50:13 2025 CST\ngpg:                using RSA key 3149FCA563772D1126249C36CC3F8CEA7B0C74D6\ngpg: Good signature from \"trident &lt;buildtrident@tron.network&gt;\"\n</code></pre></p> </li> </ol>"},{"location":"security/gpg-verification/#security-notes","title":"Security Notes","text":"<ol> <li>Always verify downloads before using them in production</li> <li>Make sure you're using the correct public key</li> <li>Download files only from official sources</li> <li>Keep your GPG installation up to date</li> </ol>"},{"location":"security/gpg-verification/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues:</p> <ol> <li>Verify you have imported the correct public key</li> <li>Ensure both the JAR and signature files are for the same version</li> <li>Check that the files were downloaded completely</li> <li>Try refreshing the GPG keyring: <code>gpg --refresh-keys</code></li> </ol>"}]}